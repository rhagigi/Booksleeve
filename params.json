{"name":"Booksleeve","body":"## How do I use it?\r\n\r\nThe entire API is async; if you don't need the result, just queue it up:\r\n\r\n```\r\nusing (var conn = new RedisConnection(\"localhost\"))\r\n{\r\n    conn.Open();\r\n    conn.Set(12, \"foo\", \"bar\");\r\n    ...\r\n}\r\n```\r\n\r\nYou can query the result of an operation as a future, by: \r\n\r\n```\r\nvar value = conn.GetString(12, \"foo\");\r\n// do something else, perhaps some TSQL, \r\n// while that flies over the network and back\r\nstring s = conn.Wait(value);\r\n```\r\n\r\nNote that the value variable here is a Task<string>; we could also use the Task API to wait (or add a continuation), but the conn.Wait(value) approach simplifies timeout-handling (waiting forever is very rarely a good idea), aggregate-exception handling, and obtaining the result value. Wait acts as a blocking call. \r\n\r\nAlternatively, if you are using the Async CTP, continuations are a breeze: \r\nvar value = conn.GetString(12, \"foo\");\r\n\r\n```\r\nstring s = await value;\r\n```\r\n\r\nA connection is thread-safe and (with the exception of Wait) non-blocking, so you can share the connection between as many callers as you need - this allows a web-site to make very effective use of just a single redis connection. Additionally, database-switching (the 12 in the examples above) is handled at the message level, so you don't need to issue separate SELECT commands - this allows multi-tenancy usage over a set of databases without having to synchronize operations.\r\n\r\n### But what if something goes badly wrong? How do I see the exceptions?\r\n\r\nIf you capture the result and use it in a Wait or a continuation, then you'll get the exception then. Otherwise the Task API exposes the exception on the TaskScheduler.UnobservedTaskException event; even if the data is \"nice to have\", you should handle this event, do something useful (like log it to your failure logs), and mark the exception as observed. If you don't do this unobserved exceptions will kill your process. Which sucks, but: \r\n\r\n```\r\nTaskScheduler.UnobservedTaskException += (sender, args) =>\r\n{\r\n    Trace.WriteLine(args.Exception,\"UnobservedTaskException\");\r\n    args.SetObserved();\r\n};\r\n```\r\n\r\n(I should note that this is nothing to do with BookSleeve; this is a feature of the Task API; if you are doing async work you should be familiar with this already)","tagline":"Pipelined Redis client for .NET (Unofficial github version)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}