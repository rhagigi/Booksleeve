<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>Booksleeve by Malediction</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Booksleeve</h1>
        <h2>Pipelined Redis client for .NET (Unofficial github version)</h2>

        <section id="downloads">
          <a href="https://github.com/Malediction/Booksleeve/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/Malediction/Booksleeve/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/Malediction/Booksleeve" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h2>How do I use it?</h2>

<p>The entire API is async; if you don't need the result, just queue it up:</p>

<pre><code>using (var conn = new RedisConnection("localhost"))
{
    conn.Open();
    conn.Set(12, "foo", "bar");
    ...
}
</code></pre>

<p>You can query the result of an operation as a future, by: </p>

<pre><code>var value = conn.GetString(12, "foo");
// do something else, perhaps some TSQL, 
// while that flies over the network and back
string s = conn.Wait(value);
</code></pre>

<p>Note that the value variable here is a Task; we could also use the Task API to wait (or add a continuation), but the conn.Wait(value) approach simplifies timeout-handling (waiting forever is very rarely a good idea), aggregate-exception handling, and obtaining the result value. Wait acts as a blocking call. </p>

<p>Alternatively, if you are using the Async CTP, continuations are a breeze: 
var value = conn.GetString(12, "foo");</p>

<pre><code>string s = await value;
</code></pre>

<p>A connection is thread-safe and (with the exception of Wait) non-blocking, so you can share the connection between as many callers as you need - this allows a web-site to make very effective use of just a single redis connection. Additionally, database-switching (the 12 in the examples above) is handled at the message level, so you don't need to issue separate SELECT commands - this allows multi-tenancy usage over a set of databases without having to synchronize operations.</p>

<h3>But what if something goes badly wrong? How do I see the exceptions?</h3>

<p>If you capture the result and use it in a Wait or a continuation, then you'll get the exception then. Otherwise the Task API exposes the exception on the TaskScheduler.UnobservedTaskException event; even if the data is "nice to have", you should handle this event, do something useful (like log it to your failure logs), and mark the exception as observed. If you don't do this unobserved exceptions will kill your process. Which sucks, but: </p>

<pre><code>TaskScheduler.UnobservedTaskException += (sender, args) =&gt;
{
    Trace.WriteLine(args.Exception,"UnobservedTaskException");
    args.SetObserved();
};
</code></pre>

<p>(I should note that this is nothing to do with BookSleeve; this is a feature of the Task API; if you are doing async work you should be familiar with this already)</p>
      </section>
    </div>

    
  </body>
</html>